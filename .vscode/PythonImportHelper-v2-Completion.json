[
    {
        "label": "Expression",
        "importPath": "nodes.expressions.Expression",
        "description": "nodes.expressions.Expression",
        "isExtraImport": true,
        "detail": "nodes.expressions.Expression",
        "documentation": {}
    },
    {
        "label": "Expression",
        "importPath": "nodes.expressions.Expression",
        "description": "nodes.expressions.Expression",
        "isExtraImport": true,
        "detail": "nodes.expressions.Expression",
        "documentation": {}
    },
    {
        "label": "Expression",
        "importPath": "nodes.expressions.Expression",
        "description": "nodes.expressions.Expression",
        "isExtraImport": true,
        "detail": "nodes.expressions.Expression",
        "documentation": {}
    },
    {
        "label": "Expression",
        "importPath": "nodes.expressions.Expression",
        "description": "nodes.expressions.Expression",
        "isExtraImport": true,
        "detail": "nodes.expressions.Expression",
        "documentation": {}
    },
    {
        "label": "Expression",
        "importPath": "nodes.expressions.Expression",
        "description": "nodes.expressions.Expression",
        "isExtraImport": true,
        "detail": "nodes.expressions.Expression",
        "documentation": {}
    },
    {
        "label": "Expression",
        "importPath": "nodes.expressions.Expression",
        "description": "nodes.expressions.Expression",
        "isExtraImport": true,
        "detail": "nodes.expressions.Expression",
        "documentation": {}
    },
    {
        "label": "Expression",
        "importPath": "nodes.expressions.Expression",
        "description": "nodes.expressions.Expression",
        "isExtraImport": true,
        "detail": "nodes.expressions.Expression",
        "documentation": {}
    },
    {
        "label": "Expression",
        "importPath": "nodes.expressions.Expression",
        "description": "nodes.expressions.Expression",
        "isExtraImport": true,
        "detail": "nodes.expressions.Expression",
        "documentation": {}
    },
    {
        "label": "Expression",
        "importPath": "nodes.expressions.Expression",
        "description": "nodes.expressions.Expression",
        "isExtraImport": true,
        "detail": "nodes.expressions.Expression",
        "documentation": {}
    },
    {
        "label": "Expression",
        "importPath": "nodes.expressions.Expression",
        "description": "nodes.expressions.Expression",
        "isExtraImport": true,
        "detail": "nodes.expressions.Expression",
        "documentation": {}
    },
    {
        "label": "Expression",
        "importPath": "nodes.expressions.Expression",
        "description": "nodes.expressions.Expression",
        "isExtraImport": true,
        "detail": "nodes.expressions.Expression",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "Program",
        "importPath": "nodes.Program",
        "description": "nodes.Program",
        "isExtraImport": true,
        "detail": "nodes.Program",
        "documentation": {}
    },
    {
        "label": "Program",
        "importPath": "nodes.Program",
        "description": "nodes.Program",
        "isExtraImport": true,
        "detail": "nodes.Program",
        "documentation": {}
    },
    {
        "label": "Program",
        "importPath": "nodes.Program",
        "description": "nodes.Program",
        "isExtraImport": true,
        "detail": "nodes.Program",
        "documentation": {}
    },
    {
        "label": "Program",
        "importPath": "nodes.Program",
        "description": "nodes.Program",
        "isExtraImport": true,
        "detail": "nodes.Program",
        "documentation": {}
    },
    {
        "label": "Program",
        "importPath": "nodes.Program",
        "description": "nodes.Program",
        "isExtraImport": true,
        "detail": "nodes.Program",
        "documentation": {}
    },
    {
        "label": "AddExpression",
        "importPath": "nodes.expressions.AddExpression",
        "description": "nodes.expressions.AddExpression",
        "isExtraImport": true,
        "detail": "nodes.expressions.AddExpression",
        "documentation": {}
    },
    {
        "label": "AddExpression",
        "importPath": "nodes.expressions.AddExpression",
        "description": "nodes.expressions.AddExpression",
        "isExtraImport": true,
        "detail": "nodes.expressions.AddExpression",
        "documentation": {}
    },
    {
        "label": "AddExpression",
        "importPath": "nodes.expressions.AddExpression",
        "description": "nodes.expressions.AddExpression",
        "isExtraImport": true,
        "detail": "nodes.expressions.AddExpression",
        "documentation": {}
    },
    {
        "label": "BraceExpression",
        "importPath": "nodes.expressions.BraceExpression",
        "description": "nodes.expressions.BraceExpression",
        "isExtraImport": true,
        "detail": "nodes.expressions.BraceExpression",
        "documentation": {}
    },
    {
        "label": "BraceExpression",
        "importPath": "nodes.expressions.BraceExpression",
        "description": "nodes.expressions.BraceExpression",
        "isExtraImport": true,
        "detail": "nodes.expressions.BraceExpression",
        "documentation": {}
    },
    {
        "label": "BraceExpression",
        "importPath": "nodes.expressions.BraceExpression",
        "description": "nodes.expressions.BraceExpression",
        "isExtraImport": true,
        "detail": "nodes.expressions.BraceExpression",
        "documentation": {}
    },
    {
        "label": "DivExpression",
        "importPath": "nodes.expressions.DivExpression",
        "description": "nodes.expressions.DivExpression",
        "isExtraImport": true,
        "detail": "nodes.expressions.DivExpression",
        "documentation": {}
    },
    {
        "label": "DivExpression",
        "importPath": "nodes.expressions.DivExpression",
        "description": "nodes.expressions.DivExpression",
        "isExtraImport": true,
        "detail": "nodes.expressions.DivExpression",
        "documentation": {}
    },
    {
        "label": "DivExpression",
        "importPath": "nodes.expressions.DivExpression",
        "description": "nodes.expressions.DivExpression",
        "isExtraImport": true,
        "detail": "nodes.expressions.DivExpression",
        "documentation": {}
    },
    {
        "label": "IdentExpression",
        "importPath": "nodes.expressions.IdentExpression",
        "description": "nodes.expressions.IdentExpression",
        "isExtraImport": true,
        "detail": "nodes.expressions.IdentExpression",
        "documentation": {}
    },
    {
        "label": "IdentExpression",
        "importPath": "nodes.expressions.IdentExpression",
        "description": "nodes.expressions.IdentExpression",
        "isExtraImport": true,
        "detail": "nodes.expressions.IdentExpression",
        "documentation": {}
    },
    {
        "label": "IdentExpression",
        "importPath": "nodes.expressions.IdentExpression",
        "description": "nodes.expressions.IdentExpression",
        "isExtraImport": true,
        "detail": "nodes.expressions.IdentExpression",
        "documentation": {}
    },
    {
        "label": "MulExpression",
        "importPath": "nodes.expressions.MulExpression",
        "description": "nodes.expressions.MulExpression",
        "isExtraImport": true,
        "detail": "nodes.expressions.MulExpression",
        "documentation": {}
    },
    {
        "label": "MulExpression",
        "importPath": "nodes.expressions.MulExpression",
        "description": "nodes.expressions.MulExpression",
        "isExtraImport": true,
        "detail": "nodes.expressions.MulExpression",
        "documentation": {}
    },
    {
        "label": "MulExpression",
        "importPath": "nodes.expressions.MulExpression",
        "description": "nodes.expressions.MulExpression",
        "isExtraImport": true,
        "detail": "nodes.expressions.MulExpression",
        "documentation": {}
    },
    {
        "label": "NumberExpression",
        "importPath": "nodes.expressions.NumberExpression",
        "description": "nodes.expressions.NumberExpression",
        "isExtraImport": true,
        "detail": "nodes.expressions.NumberExpression",
        "documentation": {}
    },
    {
        "label": "NumberExpression",
        "importPath": "nodes.expressions.NumberExpression",
        "description": "nodes.expressions.NumberExpression",
        "isExtraImport": true,
        "detail": "nodes.expressions.NumberExpression",
        "documentation": {}
    },
    {
        "label": "NumberExpression",
        "importPath": "nodes.expressions.NumberExpression",
        "description": "nodes.expressions.NumberExpression",
        "isExtraImport": true,
        "detail": "nodes.expressions.NumberExpression",
        "documentation": {}
    },
    {
        "label": "SubExpression",
        "importPath": "nodes.expressions.SubExpression",
        "description": "nodes.expressions.SubExpression",
        "isExtraImport": true,
        "detail": "nodes.expressions.SubExpression",
        "documentation": {}
    },
    {
        "label": "SubExpression",
        "importPath": "nodes.expressions.SubExpression",
        "description": "nodes.expressions.SubExpression",
        "isExtraImport": true,
        "detail": "nodes.expressions.SubExpression",
        "documentation": {}
    },
    {
        "label": "SubExpression",
        "importPath": "nodes.expressions.SubExpression",
        "description": "nodes.expressions.SubExpression",
        "isExtraImport": true,
        "detail": "nodes.expressions.SubExpression",
        "documentation": {}
    },
    {
        "label": "AssignStatement",
        "importPath": "nodes.statements.AssignStatement",
        "description": "nodes.statements.AssignStatement",
        "isExtraImport": true,
        "detail": "nodes.statements.AssignStatement",
        "documentation": {}
    },
    {
        "label": "AssignStatement",
        "importPath": "nodes.statements.AssignStatement",
        "description": "nodes.statements.AssignStatement",
        "isExtraImport": true,
        "detail": "nodes.statements.AssignStatement",
        "documentation": {}
    },
    {
        "label": "AssignStatement",
        "importPath": "nodes.statements.AssignStatement",
        "description": "nodes.statements.AssignStatement",
        "isExtraImport": true,
        "detail": "nodes.statements.AssignStatement",
        "documentation": {}
    },
    {
        "label": "AssignStatement",
        "importPath": "nodes.statements.AssignStatement",
        "description": "nodes.statements.AssignStatement",
        "isExtraImport": true,
        "detail": "nodes.statements.AssignStatement",
        "documentation": {}
    },
    {
        "label": "PrintStatement",
        "importPath": "nodes.statements.PrintStatement",
        "description": "nodes.statements.PrintStatement",
        "isExtraImport": true,
        "detail": "nodes.statements.PrintStatement",
        "documentation": {}
    },
    {
        "label": "PrintStatement",
        "importPath": "nodes.statements.PrintStatement",
        "description": "nodes.statements.PrintStatement",
        "isExtraImport": true,
        "detail": "nodes.statements.PrintStatement",
        "documentation": {}
    },
    {
        "label": "PrintStatement",
        "importPath": "nodes.statements.PrintStatement",
        "description": "nodes.statements.PrintStatement",
        "isExtraImport": true,
        "detail": "nodes.statements.PrintStatement",
        "documentation": {}
    },
    {
        "label": "PrintStatement",
        "importPath": "nodes.statements.PrintStatement",
        "description": "nodes.statements.PrintStatement",
        "isExtraImport": true,
        "detail": "nodes.statements.PrintStatement",
        "documentation": {}
    },
    {
        "label": "Visitor",
        "importPath": "visitors.Visitor",
        "description": "visitors.Visitor",
        "isExtraImport": true,
        "detail": "visitors.Visitor",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "antlr4",
        "description": "antlr4",
        "isExtraImport": true,
        "detail": "antlr4",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "antlr4",
        "description": "antlr4",
        "isExtraImport": true,
        "detail": "antlr4",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "antlr4",
        "description": "antlr4",
        "isExtraImport": true,
        "detail": "antlr4",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "antlr4",
        "description": "antlr4",
        "isExtraImport": true,
        "detail": "antlr4",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "antlr4",
        "description": "antlr4",
        "isExtraImport": true,
        "detail": "antlr4",
        "documentation": {}
    },
    {
        "label": "ExprLexer",
        "importPath": "ExprLexer",
        "description": "ExprLexer",
        "isExtraImport": true,
        "detail": "ExprLexer",
        "documentation": {}
    },
    {
        "label": "ExprParser",
        "importPath": "ExprParser",
        "description": "ExprParser",
        "isExtraImport": true,
        "detail": "ExprParser",
        "documentation": {}
    },
    {
        "label": "ExprVisitor",
        "importPath": "ExprVisitor",
        "description": "ExprVisitor",
        "isExtraImport": true,
        "detail": "ExprVisitor",
        "documentation": {}
    },
    {
        "label": "InterpreterVisitor",
        "importPath": "visitors.InterpeterVisitor",
        "description": "visitors.InterpeterVisitor",
        "isExtraImport": true,
        "detail": "visitors.InterpeterVisitor",
        "documentation": {}
    },
    {
        "label": "StringIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "StringIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "AutomatonNode",
        "importPath": "automatons.nodes.node",
        "description": "automatons.nodes.node",
        "isExtraImport": true,
        "detail": "automatons.nodes.node",
        "documentation": {}
    },
    {
        "label": "AutomatonNode",
        "importPath": "automatons.nodes.node",
        "description": "automatons.nodes.node",
        "isExtraImport": true,
        "detail": "automatons.nodes.node",
        "documentation": {}
    },
    {
        "label": "AutomatonNode",
        "importPath": "automatons.nodes.node",
        "description": "automatons.nodes.node",
        "isExtraImport": true,
        "detail": "automatons.nodes.node",
        "documentation": {}
    },
    {
        "label": "Automaton",
        "importPath": "automatons.classes.automaton",
        "description": "automatons.classes.automaton",
        "isExtraImport": true,
        "detail": "automatons.classes.automaton",
        "documentation": {}
    },
    {
        "label": "Automaton",
        "importPath": "automatons.classes.automaton",
        "description": "automatons.classes.automaton",
        "isExtraImport": true,
        "detail": "automatons.classes.automaton",
        "documentation": {}
    },
    {
        "label": "DFA_Node",
        "importPath": "automatons.nodes.dfa_node",
        "description": "automatons.nodes.dfa_node",
        "isExtraImport": true,
        "detail": "automatons.nodes.dfa_node",
        "documentation": {}
    },
    {
        "label": "DFA_Node",
        "importPath": "automatons.nodes.dfa_node",
        "description": "automatons.nodes.dfa_node",
        "isExtraImport": true,
        "detail": "automatons.nodes.dfa_node",
        "documentation": {}
    },
    {
        "label": "NFA_Node",
        "importPath": "automatons.nodes.nfa_node",
        "description": "automatons.nodes.nfa_node",
        "isExtraImport": true,
        "detail": "automatons.nodes.nfa_node",
        "documentation": {}
    },
    {
        "label": "NFA_Node",
        "importPath": "automatons.nodes.nfa_node",
        "description": "automatons.nodes.nfa_node",
        "isExtraImport": true,
        "detail": "automatons.nodes.nfa_node",
        "documentation": {}
    },
    {
        "label": "DFA",
        "importPath": "automatons.classes.dfa",
        "description": "automatons.classes.dfa",
        "isExtraImport": true,
        "detail": "automatons.classes.dfa",
        "documentation": {}
    },
    {
        "label": "DFA",
        "importPath": "automatons.classes.dfa",
        "description": "automatons.classes.dfa",
        "isExtraImport": true,
        "detail": "automatons.classes.dfa",
        "documentation": {}
    },
    {
        "label": "DFA",
        "importPath": "automatons.classes.dfa",
        "description": "automatons.classes.dfa",
        "isExtraImport": true,
        "detail": "automatons.classes.dfa",
        "documentation": {}
    },
    {
        "label": "DFA",
        "importPath": "automatons.classes.dfa",
        "description": "automatons.classes.dfa",
        "isExtraImport": true,
        "detail": "automatons.classes.dfa",
        "documentation": {}
    },
    {
        "label": "NFA",
        "importPath": "automatons.classes.nfa",
        "description": "automatons.classes.nfa",
        "isExtraImport": true,
        "detail": "automatons.classes.nfa",
        "documentation": {}
    },
    {
        "label": "NFA",
        "importPath": "automatons.classes.nfa",
        "description": "automatons.classes.nfa",
        "isExtraImport": true,
        "detail": "automatons.classes.nfa",
        "documentation": {}
    },
    {
        "label": "dfa_from_nfa",
        "importPath": "automatons.constructors.dfa_from_nfa",
        "description": "automatons.constructors.dfa_from_nfa",
        "isExtraImport": true,
        "detail": "automatons.constructors.dfa_from_nfa",
        "documentation": {}
    },
    {
        "label": "nfa_from_regex",
        "importPath": "automatons.constructors.nfa_from_regex",
        "description": "automatons.constructors.nfa_from_regex",
        "isExtraImport": true,
        "detail": "automatons.constructors.nfa_from_regex",
        "documentation": {}
    },
    {
        "label": "RegexNode",
        "importPath": "automatons.regex.regex_nodes.regex_node",
        "description": "automatons.regex.regex_nodes.regex_node",
        "isExtraImport": true,
        "detail": "automatons.regex.regex_nodes.regex_node",
        "documentation": {}
    },
    {
        "label": "RegexNode",
        "importPath": "automatons.regex.regex_nodes.regex_node",
        "description": "automatons.regex.regex_nodes.regex_node",
        "isExtraImport": true,
        "detail": "automatons.regex.regex_nodes.regex_node",
        "documentation": {}
    },
    {
        "label": "RegexNode",
        "importPath": "automatons.regex.regex_nodes.regex_node",
        "description": "automatons.regex.regex_nodes.regex_node",
        "isExtraImport": true,
        "detail": "automatons.regex.regex_nodes.regex_node",
        "documentation": {}
    },
    {
        "label": "RegexNode",
        "importPath": "automatons.regex.regex_nodes.regex_node",
        "description": "automatons.regex.regex_nodes.regex_node",
        "isExtraImport": true,
        "detail": "automatons.regex.regex_nodes.regex_node",
        "documentation": {}
    },
    {
        "label": "BinaryNode",
        "importPath": "automatons.regex.regex_nodes.binary_node",
        "description": "automatons.regex.regex_nodes.binary_node",
        "isExtraImport": true,
        "detail": "automatons.regex.regex_nodes.binary_node",
        "documentation": {}
    },
    {
        "label": "RegexOperations",
        "importPath": "automatons.regex.regex_nodes.binary_node",
        "description": "automatons.regex.regex_nodes.binary_node",
        "isExtraImport": true,
        "detail": "automatons.regex.regex_nodes.binary_node",
        "documentation": {}
    },
    {
        "label": "BinaryNode",
        "importPath": "automatons.regex.regex_nodes.binary_node",
        "description": "automatons.regex.regex_nodes.binary_node",
        "isExtraImport": true,
        "detail": "automatons.regex.regex_nodes.binary_node",
        "documentation": {}
    },
    {
        "label": "RegexOperations",
        "importPath": "automatons.regex.regex_nodes.binary_node",
        "description": "automatons.regex.regex_nodes.binary_node",
        "isExtraImport": true,
        "detail": "automatons.regex.regex_nodes.binary_node",
        "documentation": {}
    },
    {
        "label": "LeafNode",
        "importPath": "automatons.regex.regex_nodes.leaf_node",
        "description": "automatons.regex.regex_nodes.leaf_node",
        "isExtraImport": true,
        "detail": "automatons.regex.regex_nodes.leaf_node",
        "documentation": {}
    },
    {
        "label": "LeafNode",
        "importPath": "automatons.regex.regex_nodes.leaf_node",
        "description": "automatons.regex.regex_nodes.leaf_node",
        "isExtraImport": true,
        "detail": "automatons.regex.regex_nodes.leaf_node",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Visitor",
        "importPath": "automatons.regex.regex_visitors.visitor",
        "description": "automatons.regex.regex_visitors.visitor",
        "isExtraImport": true,
        "detail": "automatons.regex.regex_visitors.visitor",
        "documentation": {}
    },
    {
        "label": "Visitor",
        "importPath": "automatons.regex.regex_visitors.visitor",
        "description": "automatons.regex.regex_visitors.visitor",
        "isExtraImport": true,
        "detail": "automatons.regex.regex_visitors.visitor",
        "documentation": {}
    },
    {
        "label": "Visitor",
        "importPath": "automatons.regex.regex_visitors.visitor",
        "description": "automatons.regex.regex_visitors.visitor",
        "isExtraImport": true,
        "detail": "automatons.regex.regex_visitors.visitor",
        "documentation": {}
    },
    {
        "label": "LeafExpression",
        "importPath": "nodes.expressions.leaf_expressions",
        "description": "nodes.expressions.leaf_expressions",
        "isExtraImport": true,
        "detail": "nodes.expressions.leaf_expressions",
        "documentation": {}
    },
    {
        "label": "LeafExpression",
        "importPath": "nodes.expressions.leaf_expressions",
        "description": "nodes.expressions.leaf_expressions",
        "isExtraImport": true,
        "detail": "nodes.expressions.leaf_expressions",
        "documentation": {}
    },
    {
        "label": "\\",
        "importPath": "automatons.constructors.minimal_full_dfa_from_regex",
        "description": "automatons.constructors.minimal_full_dfa_from_regex",
        "isExtraImport": true,
        "detail": "automatons.constructors.minimal_full_dfa_from_regex",
        "documentation": {}
    },
    {
        "label": "\\",
        "importPath": "automatons.constructors.minimal_full_dfa_from_regex",
        "description": "automatons.constructors.minimal_full_dfa_from_regex",
        "isExtraImport": true,
        "detail": "automatons.constructors.minimal_full_dfa_from_regex",
        "documentation": {}
    },
    {
        "label": "BinaryNode",
        "importPath": "regex.regex_nodes.binary_node",
        "description": "regex.regex_nodes.binary_node",
        "isExtraImport": true,
        "detail": "regex.regex_nodes.binary_node",
        "documentation": {}
    },
    {
        "label": "RegexOperations",
        "importPath": "regex.regex_nodes.binary_node",
        "description": "regex.regex_nodes.binary_node",
        "isExtraImport": true,
        "detail": "regex.regex_nodes.binary_node",
        "documentation": {}
    },
    {
        "label": "BinaryNode",
        "importPath": "regex.regex_nodes.binary_node",
        "description": "regex.regex_nodes.binary_node",
        "isExtraImport": true,
        "detail": "regex.regex_nodes.binary_node",
        "documentation": {}
    },
    {
        "label": "RegexOperations",
        "importPath": "regex.regex_nodes.binary_node",
        "description": "regex.regex_nodes.binary_node",
        "isExtraImport": true,
        "detail": "regex.regex_nodes.binary_node",
        "documentation": {}
    },
    {
        "label": "LeafNode",
        "importPath": "regex.regex_nodes.leaf_node",
        "description": "regex.regex_nodes.leaf_node",
        "isExtraImport": true,
        "detail": "regex.regex_nodes.leaf_node",
        "documentation": {}
    },
    {
        "label": "LeafNode",
        "importPath": "regex.regex_nodes.leaf_node",
        "description": "regex.regex_nodes.leaf_node",
        "isExtraImport": true,
        "detail": "regex.regex_nodes.leaf_node",
        "documentation": {}
    },
    {
        "label": "TOKENS_REGEXPS",
        "importPath": "scanner.token_regexps",
        "description": "scanner.token_regexps",
        "isExtraImport": true,
        "detail": "scanner.token_regexps",
        "documentation": {}
    },
    {
        "label": "KeyWord",
        "importPath": "nodes.KeyWord",
        "description": "nodes.KeyWord",
        "isExtraImport": true,
        "detail": "nodes.KeyWord",
        "documentation": {}
    },
    {
        "label": "Bool",
        "importPath": "nodes.expressions.leaf_expressions.bool",
        "description": "nodes.expressions.leaf_expressions.bool",
        "isExtraImport": true,
        "detail": "nodes.expressions.leaf_expressions.bool",
        "documentation": {}
    },
    {
        "label": "Number",
        "importPath": "nodes.expressions.leaf_expressions.number",
        "description": "nodes.expressions.leaf_expressions.number",
        "isExtraImport": true,
        "detail": "nodes.expressions.leaf_expressions.number",
        "documentation": {}
    },
    {
        "label": "String",
        "importPath": "nodes.expressions.leaf_expressions.str",
        "description": "nodes.expressions.leaf_expressions.str",
        "isExtraImport": true,
        "detail": "nodes.expressions.leaf_expressions.str",
        "documentation": {}
    },
    {
        "label": "QUOTE",
        "importPath": "scanner.alphabet",
        "description": "scanner.alphabet",
        "isExtraImport": true,
        "detail": "scanner.alphabet",
        "documentation": {}
    },
    {
        "label": "SPEC_SYMBOLS",
        "importPath": "scanner.alphabet",
        "description": "scanner.alphabet",
        "isExtraImport": true,
        "detail": "scanner.alphabet",
        "documentation": {}
    },
    {
        "label": "NUMBERS",
        "importPath": "scanner.alphabet",
        "description": "scanner.alphabet",
        "isExtraImport": true,
        "detail": "scanner.alphabet",
        "documentation": {}
    },
    {
        "label": "alphabet",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "alphabet",
        "description": "alphabet",
        "detail": "alphabet",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "site",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "site",
        "description": "site",
        "detail": "site",
        "documentation": {}
    },
    {
        "label": "tests",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tests",
        "description": "tests",
        "detail": "tests",
        "documentation": {}
    },
    {
        "label": "AddExpression",
        "kind": 6,
        "importPath": "antlr.nodes.expressions.AddExpression",
        "description": "antlr.nodes.expressions.AddExpression",
        "peekOfCode": "class AddExpression(Expression):\n    def __init__(\n        self,\n        left: Expression,\n        right: Expression\n    ) -> None:\n        self.left = left\n        self.right = right\n    def accept(self, visitor):\n        return visitor.visit_add_expression(self)",
        "detail": "antlr.nodes.expressions.AddExpression",
        "documentation": {}
    },
    {
        "label": "BraceExpression",
        "kind": 6,
        "importPath": "antlr.nodes.expressions.BraceExpression",
        "description": "antlr.nodes.expressions.BraceExpression",
        "peekOfCode": "class BraceExpression(Expression):\n    def __init__(\n        self,\n        expression: Expression\n    ) -> None:\n        self.expression = expression\n    def accept(self, visitor):\n        return visitor.visit_brace_expression(self)",
        "detail": "antlr.nodes.expressions.BraceExpression",
        "documentation": {}
    },
    {
        "label": "DivExpression",
        "kind": 6,
        "importPath": "antlr.nodes.expressions.DivExpression",
        "description": "antlr.nodes.expressions.DivExpression",
        "peekOfCode": "class DivExpression(Expression):\n    def __init__(\n        self,\n        left: Expression,\n        right: Expression\n    ) -> None:\n        self.left = left\n        self.right = right\n    def accept(self, visitor):\n        return visitor.visit_div_expression(self)",
        "detail": "antlr.nodes.expressions.DivExpression",
        "documentation": {}
    },
    {
        "label": "Expression",
        "kind": 6,
        "importPath": "antlr.nodes.expressions.Expression",
        "description": "antlr.nodes.expressions.Expression",
        "peekOfCode": "class Expression(ABC):\n    @abstractmethod\n    def accept(self, visitor):\n        pass",
        "detail": "antlr.nodes.expressions.Expression",
        "documentation": {}
    },
    {
        "label": "IdentExpression",
        "kind": 6,
        "importPath": "antlr.nodes.expressions.IdentExpression",
        "description": "antlr.nodes.expressions.IdentExpression",
        "peekOfCode": "class IdentExpression(Expression):\n    def __init__(\n        self,\n        name: str,\n    ) -> None:\n        self.name = name\n    def accept(self, visitor):\n        return visitor.visit_ident_expression(self)",
        "detail": "antlr.nodes.expressions.IdentExpression",
        "documentation": {}
    },
    {
        "label": "MulExpression",
        "kind": 6,
        "importPath": "antlr.nodes.expressions.MulExpression",
        "description": "antlr.nodes.expressions.MulExpression",
        "peekOfCode": "class MulExpression(Expression):\n    def __init__(\n        self,\n        left: Expression,\n        right: Expression\n    ) -> None:\n        self.left = left\n        self.right = right\n    def accept(self, visitor):\n        return visitor.visit_mul_expression(self)",
        "detail": "antlr.nodes.expressions.MulExpression",
        "documentation": {}
    },
    {
        "label": "NumberExpression",
        "kind": 6,
        "importPath": "antlr.nodes.expressions.NumberExpression",
        "description": "antlr.nodes.expressions.NumberExpression",
        "peekOfCode": "class NumberExpression(Expression):\n    def __init__(self, number: str) -> None:\n        self.number = int(number)\n    def accept(self, visitor):\n        return visitor.visit_number_expression(self)",
        "detail": "antlr.nodes.expressions.NumberExpression",
        "documentation": {}
    },
    {
        "label": "SubExpression",
        "kind": 6,
        "importPath": "antlr.nodes.expressions.SubExpression",
        "description": "antlr.nodes.expressions.SubExpression",
        "peekOfCode": "class SubExpression(Expression):\n    def __init__(\n        self,\n        left: Expression,\n        right: Expression\n    ) -> None:\n        self.left = left\n        self.right = right\n    def accept(self, visitor):\n        return visitor.visit_sub_expression(self)",
        "detail": "antlr.nodes.expressions.SubExpression",
        "documentation": {}
    },
    {
        "label": "AssignStatement",
        "kind": 6,
        "importPath": "antlr.nodes.statements.AssignStatement",
        "description": "antlr.nodes.statements.AssignStatement",
        "peekOfCode": "class AssignStatement:\n    def __init__(\n        self,\n        variable: str,\n        expression: Expression,\n    ) -> None:\n        self.variable = variable\n        self.expression = expression\n    def accept(self, visitor):\n        return visitor.visit_assign_statement(self)",
        "detail": "antlr.nodes.statements.AssignStatement",
        "documentation": {}
    },
    {
        "label": "PrintStatement",
        "kind": 6,
        "importPath": "antlr.nodes.statements.PrintStatement",
        "description": "antlr.nodes.statements.PrintStatement",
        "peekOfCode": "class PrintStatement:\n    def __init__(\n        self,\n        expression: Expression\n    ) -> None:\n        self.expression = expression\n    def accept(self, visitor):\n        return visitor.visit_print_statement(self)",
        "detail": "antlr.nodes.statements.PrintStatement",
        "documentation": {}
    },
    {
        "label": "KeyWord",
        "kind": 6,
        "importPath": "antlr.nodes.KeyWord",
        "description": "antlr.nodes.KeyWord",
        "peekOfCode": "class KeyWord(Expression):\n    def __init__(self, word):\n        super().__init__(\"KEYWORD\")\n        self.value = word\n    def __str__(self):\n        return f\"{self.name}({self.value})\"",
        "detail": "antlr.nodes.KeyWord",
        "documentation": {}
    },
    {
        "label": "Program",
        "kind": 6,
        "importPath": "antlr.nodes.Program",
        "description": "antlr.nodes.Program",
        "peekOfCode": "class Program:\n    def __init__(\n        self,\n        expressions: list[Expression]\n    ) -> None:\n        self.expressions = expressions\n    def accept(self, visitor):\n        return visitor.visit_program(self)",
        "detail": "antlr.nodes.Program",
        "documentation": {}
    },
    {
        "label": "InterpreterVisitor",
        "kind": 6,
        "importPath": "antlr.visitors.InterpeterVisitor",
        "description": "antlr.visitors.InterpeterVisitor",
        "peekOfCode": "class InterpreterVisitor(Visitor):\n    def __init__(self) -> None:\n        self.variables = {}\n    def visit_number_expression(self, expression: NumberExpression):\n        return expression.number\n    def visit_add_expression(self, expression: AddExpression):\n        return expression.left.accept(self) + expression.right.accept(self)\n    def visit_sub_expression(self, expression: SubExpression):\n        return expression.left.accept(self) - expression.right.accept(self)\n    def visit_mul_expression(self, expression: MulExpression):",
        "detail": "antlr.visitors.InterpeterVisitor",
        "documentation": {}
    },
    {
        "label": "Visitor",
        "kind": 6,
        "importPath": "antlr.visitors.Visitor",
        "description": "antlr.visitors.Visitor",
        "peekOfCode": "class Visitor(ABC):\n    @abstractmethod\n    def visit_number_expression(self, expression: NumberExpression):\n        pass\n    @abstractmethod\n    def visit_add_expression(self, expression: AddExpression):\n        pass\n    @abstractmethod\n    def visit_sub_expression(self, expression: SubExpression):\n        pass",
        "detail": "antlr.visitors.Visitor",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "antlr.Driver",
        "description": "antlr.Driver",
        "peekOfCode": "def main(argv):\n    input_stream = FileStream('input.txt')\n    lexer = ExprLexer(input_stream)\n    stream = CommonTokenStream(lexer)\n    parser = ExprParser(stream)\n    tree = parser.prog()\n    ast_tree: Program = ExprVisitor().visit(tree)\n    print(ast_tree.expressions)\n    try:\n        interpeter = InterpreterVisitor()",
        "detail": "antlr.Driver",
        "documentation": {}
    },
    {
        "label": "ExprLexer",
        "kind": 6,
        "importPath": "antlr.ExprLexer",
        "description": "antlr.ExprLexer",
        "peekOfCode": "class ExprLexer(Lexer):\n    atn = ATNDeserializer().deserialize(serializedATN())\n    decisionsToDFA = [DFA(ds, i) for i, ds in enumerate(atn.decisionToState)]\n    T__0 = 1\n    T__1 = 2\n    T__2 = 3\n    T__3 = 4\n    T__4 = 5\n    T__5 = 6\n    T__6 = 7",
        "detail": "antlr.ExprLexer",
        "documentation": {}
    },
    {
        "label": "serializedATN",
        "kind": 2,
        "importPath": "antlr.ExprLexer",
        "description": "antlr.ExprLexer",
        "peekOfCode": "def serializedATN():\n    return [\n        4, 0, 16, 90, 6, -\n        1, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 7, 4, 2, 5, 7, 5, 2,\n        6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10, 7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13,\n        7, 13, 2, 14, 7, 14, 2, 15, 7, 15, 1, 0, 1, 0, 1, 1, 1, 1, 1, 2, 1, 2, 1, 3, 1, 3, 1, 4, 1, 4,\n        1, 4, 1, 4, 1, 4, 1, 4, 1, 5, 1, 5, 1, 6, 1, 6, 1, 7, 1, 7, 1, 8, 1, 8, 1, 9, 1, 9, 1, 10, 1, 10,\n        1, 10, 1, 10, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 3, 11, 69, 8, 11, 1, 12, 1,\n        12, 1, 12, 1, 12, 1, 12, 1, 13, 4, 13, 77, 8, 13, 11, 13, 12, 13, 78, 1, 14, 4, 14, 82,\n        8, 14, 11, 14, 12, 14, 83, 1, 15, 4, 15, 87, 8, 15, 11, 15, 12, 15, 88, 0, 0, 16, 1, 1,",
        "detail": "antlr.ExprLexer",
        "documentation": {}
    },
    {
        "label": "ExprListener",
        "kind": 6,
        "importPath": "antlr.ExprListener",
        "description": "antlr.ExprListener",
        "peekOfCode": "class ExprListener(ParseTreeListener):\n    # Enter a parse tree produced by ExprParser#prog.\n    def enterProg(self, ctx: ExprParser.ProgContext):\n        print(ctx)\n    # Exit a parse tree produced by ExprParser#prog.\n    def exitProg(self, ctx: ExprParser.ProgContext):\n        print(ctx)\n    # Enter a parse tree produced by ExprParser#stmt.\n    def enterStmt(self, ctx: ExprParser.StmtContext):\n        print(ctx)",
        "detail": "antlr.ExprListener",
        "documentation": {}
    },
    {
        "label": "ExprParse",
        "kind": 6,
        "importPath": "antlr.ExprParser",
        "description": "antlr.ExprParser",
        "peekOfCode": "class ExprParser (Parser):\n    grammarFileName = \"Expr.g4\"\n    atn = ATNDeserializer().deserialize(serializedATN())\n    decisionsToDFA = [DFA(ds, i) for i, ds in enumerate(atn.decisionToState)]\n    sharedContextCache = PredictionContextCache()\n    literalNames = [\"<INVALID>\", \"'('\", \"')'\", \"'{'\", \"'}'\", \"'print'\",\n                     \"'='\", \"'*'\", \"'/'\", \"'+'\", \"'-'\", \"<INVALID>\", \"<INVALID>\",\n                     \"'main'\"]\n    symbolicNames = [\"<INVALID>\", \"<INVALID>\", \"<INVALID>\", \"<INVALID>\",\n                      \"<INVALID>\", \"<INVALID>\", \"<INVALID>\", \"<INVALID>\",",
        "detail": "antlr.ExprParser",
        "documentation": {}
    },
    {
        "label": "serializedATN",
        "kind": 2,
        "importPath": "antlr.ExprParser",
        "description": "antlr.ExprParser",
        "peekOfCode": "def serializedATN():\n    return [\n        4, 1, 16, 50, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,\n        0, 1, 0, 5, 0, 16, 8, 0, 10, 0, 12, 0, 19, 9, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3,\n        1, 28, 8, 1, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 3, 2, 37, 8, 2, 1, 2, 1, 2, 1, 2, 1, 2,\n        1, 2, 1, 2, 5, 2, 45, 8, 2, 10, 2, 12, 2, 48, 9, 2, 1, 2, 0, 1, 4, 3, 0, 2, 4, 0, 2, 1, 0, 7,\n        8, 1, 0, 9, 10, 52, 0, 6, 1, 0, 0, 0, 2, 27, 1, 0, 0, 0, 4, 36, 1, 0, 0, 0, 6, 7, 5, 12, 0, 0,\n        7, 8, 5, 13, 0, 0, 8, 9, 5, 1, 0, 0, 9, 10, 5, 2, 0, 0, 10, 11, 5, 3, 0, 0, 11, 17, 5, 14, 0,\n        0, 12, 13, 3, 2, 1, 0, 13, 14, 5, 14, 0, 0, 14, 16, 1, 0, 0, 0, 15, 12, 1, 0, 0, 0, 16, 19,\n        1, 0, 0, 0, 17, 15, 1, 0, 0, 0, 17, 18, 1, 0, 0, 0, 18, 20, 1, 0, 0, 0, 19, 17, 1, 0, 0, 0,",
        "detail": "antlr.ExprParser",
        "documentation": {}
    },
    {
        "label": "ExprVisitor",
        "kind": 6,
        "importPath": "antlr.ExprVisitor",
        "description": "antlr.ExprVisitor",
        "peekOfCode": "class ExprVisitor(ParseTreeVisitor):\n    # Visit a parse tree produced by ExprParser#prog.\n    def visitProg(self, ctx: ExprParser.ProgContext):\n        statements = []\n        for statement in ctx.stmt():\n            statements.append(self.visit(statement))\n        return Program(expressions=statements)\n    def visitStmt(self, ctx: ExprParser.StmtContext):\n        if ctx.assign is not None:\n            return AssignStatement(",
        "detail": "antlr.ExprVisitor",
        "documentation": {}
    },
    {
        "label": "Automaton",
        "kind": 6,
        "importPath": "automatons.classes.automaton",
        "description": "automatons.classes.automaton",
        "peekOfCode": "class Automaton:\n    def __init__(self, alphabet=None):\n        self.root = AutomatonNode()\n        self.states = set()\n        self.alphabet = alphabet if alphabet is not None else set()\n    def add_nodes(self, automatons: list):\n        for automaton in automatons:\n            for state in automaton.states:\n                self.states.add(state)",
        "detail": "automatons.classes.automaton",
        "documentation": {}
    },
    {
        "label": "DFA",
        "kind": 6,
        "importPath": "automatons.classes.dfa",
        "description": "automatons.classes.dfa",
        "peekOfCode": "class DFA(Automaton):\n    def __init__(self, alphabet=None):\n        super().__init__()\n        self.root = DFA_Node()\n        self.trash = DFA_Node()\n        self.states.add(self.root)\n        self.states.add(self.trash)\n    def add_edge(self, source: DFA_Node, target: DFA_Node, letter: str):\n        self.states.add(source)\n        self.states.add(target)",
        "detail": "automatons.classes.dfa",
        "documentation": {}
    },
    {
        "label": "NFA",
        "kind": 6,
        "importPath": "automatons.classes.nfa",
        "description": "automatons.classes.nfa",
        "peekOfCode": "class NFA(Automaton):\n    def __init__(self, alphabet=None):\n        super().__init__()\n        self.root = NFA_Node()\n        self.sink = NFA_Node()\n        self.states.add(self.root)\n        self.states.add(self.sink)\n    def add_edge(self, source: NFA_Node, target: NFA_Node, letter: str):\n        self.states.add(source)\n        self.states.add(target)",
        "detail": "automatons.classes.nfa",
        "documentation": {}
    },
    {
        "label": "get_move",
        "kind": 2,
        "importPath": "automatons.constructors.dfa_from_nfa",
        "description": "automatons.constructors.dfa_from_nfa",
        "peekOfCode": "def get_move(source: set[NFA_Node], letter: str) -> set[NFA_Node]:\n    move = set()\n    for node in source:\n        if letter in node.to.keys():\n            for neighbour in node.to[letter]:\n                move.add(neighbour)\n    return move\ndef dfa_from_nfa(nfa: NFA) -> DFA:\n    dfa_nodes = []\n    transitions = dict()",
        "detail": "automatons.constructors.dfa_from_nfa",
        "documentation": {}
    },
    {
        "label": "dfa_from_nfa",
        "kind": 2,
        "importPath": "automatons.constructors.dfa_from_nfa",
        "description": "automatons.constructors.dfa_from_nfa",
        "peekOfCode": "def dfa_from_nfa(nfa: NFA) -> DFA:\n    dfa_nodes = []\n    transitions = dict()\n    queue = [frozenset([nfa.root])]\n    dfa_nodes.append(frozenset([nfa.root]))\n    used = set()\n    while len(queue) > 0:\n        curr_state = queue.pop(0)\n        letters = set()\n        for vert in curr_state:",
        "detail": "automatons.constructors.dfa_from_nfa",
        "documentation": {}
    },
    {
        "label": "minimal_full_dfa_from_regex",
        "kind": 2,
        "importPath": "automatons.constructors.minimal_full_dfa_from_regex",
        "description": "automatons.constructors.minimal_full_dfa_from_regex",
        "peekOfCode": "def minimal_full_dfa_from_regex(regex: RegexNode) -> DFA:\n    nfa = nfa_from_regex(regex)\n    nfa.delete_epsilon_transitions()\n    dfa = dfa_from_nfa(nfa)\n    dfa.minimize()\n    dfa.make_full()\n    return dfa",
        "detail": "automatons.constructors.minimal_full_dfa_from_regex",
        "documentation": {}
    },
    {
        "label": "nfa_from_regex",
        "kind": 2,
        "importPath": "automatons.constructors.nfa_from_regex",
        "description": "automatons.constructors.nfa_from_regex",
        "peekOfCode": "def nfa_from_regex(regex: RegexNode):\n    if isinstance(regex, LeafNode):\n        return nfa_from_leaf_node(regex)\n    else:\n        return nfa_from_binary_node(regex)\ndef nfa_from_leaf_node(regex: LeafNode) -> NFA:\n    nfa = NFA()\n    nfa.add_edge(nfa.root, nfa.sink, regex.letter)\n    return nfa\ndef nfa_from_binary_node(regex: BinaryNode) -> NFA:",
        "detail": "automatons.constructors.nfa_from_regex",
        "documentation": {}
    },
    {
        "label": "nfa_from_leaf_node",
        "kind": 2,
        "importPath": "automatons.constructors.nfa_from_regex",
        "description": "automatons.constructors.nfa_from_regex",
        "peekOfCode": "def nfa_from_leaf_node(regex: LeafNode) -> NFA:\n    nfa = NFA()\n    nfa.add_edge(nfa.root, nfa.sink, regex.letter)\n    return nfa\ndef nfa_from_binary_node(regex: BinaryNode) -> NFA:\n    nfa = NFA()\n    automatons = prepare_automatons([regex.exp1, regex.exp2])\n    if regex.operation == RegexOperations.CLOSURE:\n        nfa.root.by_eps.add(automatons[0].root)\n        nfa.root.by_eps.add(nfa.sink)",
        "detail": "automatons.constructors.nfa_from_regex",
        "documentation": {}
    },
    {
        "label": "nfa_from_binary_node",
        "kind": 2,
        "importPath": "automatons.constructors.nfa_from_regex",
        "description": "automatons.constructors.nfa_from_regex",
        "peekOfCode": "def nfa_from_binary_node(regex: BinaryNode) -> NFA:\n    nfa = NFA()\n    automatons = prepare_automatons([regex.exp1, regex.exp2])\n    if regex.operation == RegexOperations.CLOSURE:\n        nfa.root.by_eps.add(automatons[0].root)\n        nfa.root.by_eps.add(nfa.sink)\n        nfa.sink.by_eps.add(automatons[0].root)\n        automatons[0].sink.by_eps.add(nfa.sink)\n    elif regex.operation == RegexOperations.UNITE:\n        nfa.root.by_eps.add(automatons[0].root)",
        "detail": "automatons.constructors.nfa_from_regex",
        "documentation": {}
    },
    {
        "label": "prepare_automatons",
        "kind": 2,
        "importPath": "automatons.constructors.nfa_from_regex",
        "description": "automatons.constructors.nfa_from_regex",
        "peekOfCode": "def prepare_automatons(regexps: list[RegexNode]) -> list[NFA]:\n    ans = []\n    for reg in regexps:\n        if reg is not None:\n            nfa = nfa_from_regex(reg)\n            ans.append(nfa)\n    return ans",
        "detail": "automatons.constructors.nfa_from_regex",
        "documentation": {}
    },
    {
        "label": "DFA_Node",
        "kind": 6,
        "importPath": "automatons.nodes.dfa_node",
        "description": "automatons.nodes.dfa_node",
        "peekOfCode": "class DFA_Node(AutomatonNode):\n    def __init__(self, nfa_nodes_set=None):\n        super().__init__()\n        if nfa_nodes_set is not None:\n            for node in nfa_nodes_set:\n                for token in node.terminal:\n                    self.terminal.add(token)\n    def accept(self, visitor):\n        return self.terminal",
        "detail": "automatons.nodes.dfa_node",
        "documentation": {}
    },
    {
        "label": "NFA_Node",
        "kind": 6,
        "importPath": "automatons.nodes.nfa_node",
        "description": "automatons.nodes.nfa_node",
        "peekOfCode": "class NFA_Node(AutomatonNode):\n    def __init__(self):\n        super().__init__()\n        self.to = dict()\n        self.by_eps = set()",
        "detail": "automatons.nodes.nfa_node",
        "documentation": {}
    },
    {
        "label": "AutomatonNode",
        "kind": 6,
        "importPath": "automatons.nodes.node",
        "description": "automatons.nodes.node",
        "peekOfCode": "class AutomatonNode:\n    def __init__(self):\n        self.to = dict()\n        self.terminal = set()\n    def make_terminal(self, token: str):\n        self.terminal.add(token)",
        "detail": "automatons.nodes.node",
        "documentation": {}
    },
    {
        "label": "RegexOperations",
        "kind": 6,
        "importPath": "automatons.regex.regex_nodes.binary_node",
        "description": "automatons.regex.regex_nodes.binary_node",
        "peekOfCode": "class RegexOperations(Enum):\n    CONCAT = \"X\"\n    UNITE = \"+\"\n    CLOSURE = \"*\"\nclass BinaryNode(RegexNode):\n    def __init__(self, left: RegexNode, right: RegexNode, operation: RegexOperations):\n        self.exp1 = left\n        self.exp2 = right\n        self.operation = operation\n    def __str__(self):",
        "detail": "automatons.regex.regex_nodes.binary_node",
        "documentation": {}
    },
    {
        "label": "BinaryNode",
        "kind": 6,
        "importPath": "automatons.regex.regex_nodes.binary_node",
        "description": "automatons.regex.regex_nodes.binary_node",
        "peekOfCode": "class BinaryNode(RegexNode):\n    def __init__(self, left: RegexNode, right: RegexNode, operation: RegexOperations):\n        self.exp1 = left\n        self.exp2 = right\n        self.operation = operation\n    def __str__(self):\n        if self.operation == RegexOperations.CLOSURE:\n            return f'({self.exp1})*'\n        if self.operation == RegexOperations.CONCAT:\n            return f'{self.exp1}{self.exp2}'",
        "detail": "automatons.regex.regex_nodes.binary_node",
        "documentation": {}
    },
    {
        "label": "LeafNode",
        "kind": 6,
        "importPath": "automatons.regex.regex_nodes.leaf_node",
        "description": "automatons.regex.regex_nodes.leaf_node",
        "peekOfCode": "class LeafNode(RegexNode):\n    def __init__(self, letter: str = None):\n        self.letter = letter\n    def accept(self, visitor: Visitor):\n        return visitor.visit(self)\n    def __str__(self):\n        return self.letter",
        "detail": "automatons.regex.regex_nodes.leaf_node",
        "documentation": {}
    },
    {
        "label": "RegexNode",
        "kind": 6,
        "importPath": "automatons.regex.regex_nodes.regex_node",
        "description": "automatons.regex.regex_nodes.regex_node",
        "peekOfCode": "class RegexNode:\n    @abstractmethod\n    def accept(self, visitor: Visitor):\n        pass\n    def __hash__(self):\n        return str(self).__hash__()\n    def __eq__(self, other):\n        return str(self) == str(other)",
        "detail": "automatons.regex.regex_nodes.regex_node",
        "documentation": {}
    },
    {
        "label": "Visitor",
        "kind": 6,
        "importPath": "automatons.regex.regex_visitors.visitor",
        "description": "automatons.regex.regex_visitors.visitor",
        "peekOfCode": "class Visitor:\n    def __init__(self):\n        pass\n    def visit(self, node):\n        pass",
        "detail": "automatons.regex.regex_visitors.visitor",
        "documentation": {}
    },
    {
        "label": "InterpreterVisitor",
        "kind": 6,
        "importPath": "interpreter.interpreter-visitor",
        "description": "interpreter.interpreter-visitor",
        "peekOfCode": "class InterpreterVisitor:\n    def __init__(self) -> None:\n        self.variables = {}\n    def visit_leaf_expression(self, expression: LeafExpression):\n        return expression.value\n    def visit_program(self, program: Program):\n        program.accept(self)\n    def visit_assign_statement(self, statement: AssignStatement):\n        self.variables[statement.variable] = statement.expression.accept(self)\n    def visit_print_statement(self, statement: PrintStatement):",
        "detail": "interpreter.interpreter-visitor",
        "documentation": {}
    },
    {
        "label": "NUMBERS",
        "kind": 5,
        "importPath": "scanner.alphabet",
        "description": "scanner.alphabet",
        "peekOfCode": "NUMBERS = '0123456789'\nLETTERS = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\nL_ROUND_BR = '('\nR_ROUND_BR = ')'\nL_FIGURE_BR = '{'\nR_FIGURE_BR = '}'\nQUOTE = '\"'\nSEMICOLON = ';'\nDOT = '.'\nSPACE = ' '",
        "detail": "scanner.alphabet",
        "documentation": {}
    },
    {
        "label": "LETTERS",
        "kind": 5,
        "importPath": "scanner.alphabet",
        "description": "scanner.alphabet",
        "peekOfCode": "LETTERS = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\nL_ROUND_BR = '('\nR_ROUND_BR = ')'\nL_FIGURE_BR = '{'\nR_FIGURE_BR = '}'\nQUOTE = '\"'\nSEMICOLON = ';'\nDOT = '.'\nSPACE = ' '\nUNDERSCORE = '_'",
        "detail": "scanner.alphabet",
        "documentation": {}
    },
    {
        "label": "L_ROUND_BR",
        "kind": 5,
        "importPath": "scanner.alphabet",
        "description": "scanner.alphabet",
        "peekOfCode": "L_ROUND_BR = '('\nR_ROUND_BR = ')'\nL_FIGURE_BR = '{'\nR_FIGURE_BR = '}'\nQUOTE = '\"'\nSEMICOLON = ';'\nDOT = '.'\nSPACE = ' '\nUNDERSCORE = '_'\nSPEC_SYMBOLS = (L_ROUND_BR + R_ROUND_BR + L_FIGURE_BR + R_FIGURE_BR +",
        "detail": "scanner.alphabet",
        "documentation": {}
    },
    {
        "label": "R_ROUND_BR",
        "kind": 5,
        "importPath": "scanner.alphabet",
        "description": "scanner.alphabet",
        "peekOfCode": "R_ROUND_BR = ')'\nL_FIGURE_BR = '{'\nR_FIGURE_BR = '}'\nQUOTE = '\"'\nSEMICOLON = ';'\nDOT = '.'\nSPACE = ' '\nUNDERSCORE = '_'\nSPEC_SYMBOLS = (L_ROUND_BR + R_ROUND_BR + L_FIGURE_BR + R_FIGURE_BR +\n                QUOTE + SEMICOLON + DOT)",
        "detail": "scanner.alphabet",
        "documentation": {}
    },
    {
        "label": "L_FIGURE_BR",
        "kind": 5,
        "importPath": "scanner.alphabet",
        "description": "scanner.alphabet",
        "peekOfCode": "L_FIGURE_BR = '{'\nR_FIGURE_BR = '}'\nQUOTE = '\"'\nSEMICOLON = ';'\nDOT = '.'\nSPACE = ' '\nUNDERSCORE = '_'\nSPEC_SYMBOLS = (L_ROUND_BR + R_ROUND_BR + L_FIGURE_BR + R_FIGURE_BR +\n                QUOTE + SEMICOLON + DOT)",
        "detail": "scanner.alphabet",
        "documentation": {}
    },
    {
        "label": "R_FIGURE_BR",
        "kind": 5,
        "importPath": "scanner.alphabet",
        "description": "scanner.alphabet",
        "peekOfCode": "R_FIGURE_BR = '}'\nQUOTE = '\"'\nSEMICOLON = ';'\nDOT = '.'\nSPACE = ' '\nUNDERSCORE = '_'\nSPEC_SYMBOLS = (L_ROUND_BR + R_ROUND_BR + L_FIGURE_BR + R_FIGURE_BR +\n                QUOTE + SEMICOLON + DOT)",
        "detail": "scanner.alphabet",
        "documentation": {}
    },
    {
        "label": "QUOTE",
        "kind": 5,
        "importPath": "scanner.alphabet",
        "description": "scanner.alphabet",
        "peekOfCode": "QUOTE = '\"'\nSEMICOLON = ';'\nDOT = '.'\nSPACE = ' '\nUNDERSCORE = '_'\nSPEC_SYMBOLS = (L_ROUND_BR + R_ROUND_BR + L_FIGURE_BR + R_FIGURE_BR +\n                QUOTE + SEMICOLON + DOT)",
        "detail": "scanner.alphabet",
        "documentation": {}
    },
    {
        "label": "SEMICOLON",
        "kind": 5,
        "importPath": "scanner.alphabet",
        "description": "scanner.alphabet",
        "peekOfCode": "SEMICOLON = ';'\nDOT = '.'\nSPACE = ' '\nUNDERSCORE = '_'\nSPEC_SYMBOLS = (L_ROUND_BR + R_ROUND_BR + L_FIGURE_BR + R_FIGURE_BR +\n                QUOTE + SEMICOLON + DOT)",
        "detail": "scanner.alphabet",
        "documentation": {}
    },
    {
        "label": "DOT",
        "kind": 5,
        "importPath": "scanner.alphabet",
        "description": "scanner.alphabet",
        "peekOfCode": "DOT = '.'\nSPACE = ' '\nUNDERSCORE = '_'\nSPEC_SYMBOLS = (L_ROUND_BR + R_ROUND_BR + L_FIGURE_BR + R_FIGURE_BR +\n                QUOTE + SEMICOLON + DOT)",
        "detail": "scanner.alphabet",
        "documentation": {}
    },
    {
        "label": "SPACE",
        "kind": 5,
        "importPath": "scanner.alphabet",
        "description": "scanner.alphabet",
        "peekOfCode": "SPACE = ' '\nUNDERSCORE = '_'\nSPEC_SYMBOLS = (L_ROUND_BR + R_ROUND_BR + L_FIGURE_BR + R_FIGURE_BR +\n                QUOTE + SEMICOLON + DOT)",
        "detail": "scanner.alphabet",
        "documentation": {}
    },
    {
        "label": "UNDERSCORE",
        "kind": 5,
        "importPath": "scanner.alphabet",
        "description": "scanner.alphabet",
        "peekOfCode": "UNDERSCORE = '_'\nSPEC_SYMBOLS = (L_ROUND_BR + R_ROUND_BR + L_FIGURE_BR + R_FIGURE_BR +\n                QUOTE + SEMICOLON + DOT)",
        "detail": "scanner.alphabet",
        "documentation": {}
    },
    {
        "label": "SPEC_SYMBOLS",
        "kind": 5,
        "importPath": "scanner.alphabet",
        "description": "scanner.alphabet",
        "peekOfCode": "SPEC_SYMBOLS = (L_ROUND_BR + R_ROUND_BR + L_FIGURE_BR + R_FIGURE_BR +\n                QUOTE + SEMICOLON + DOT)",
        "detail": "scanner.alphabet",
        "documentation": {}
    },
    {
        "label": "get_dfa_for_tokens",
        "kind": 2,
        "importPath": "scanner.dfa_for_tokens",
        "description": "scanner.dfa_for_tokens",
        "peekOfCode": "def get_dfa_for_tokens() -> DFA:\n    final_mega_regex = LeafNode()\n    for token in TOKENS:\n        final_mega_regex = BinaryNode(final_mega_regex, TOKENS_REGEXPS[token],\n                                      RegexOperations.UNITE)\n    mdfa = minimal_full_dfa_from_regex(final_mega_regex)\n    return mdfa",
        "detail": "scanner.dfa_for_tokens",
        "documentation": {}
    },
    {
        "label": "TOKENS",
        "kind": 5,
        "importPath": "scanner.dfa_for_tokens",
        "description": "scanner.dfa_for_tokens",
        "peekOfCode": "TOKENS = [\n    \"L_ROUND_BR\",\n    \"R_ROUND_BR\",\n    \"L_FIGURE_BR\",\n    \"R_FIGURE_BR\",\n    \"QUOTE\",\n    \"SEMICOLON\",\n    \"DOT\",\n    \"UNDERSCORE\",\n    \"VARNAME\"",
        "detail": "scanner.dfa_for_tokens",
        "documentation": {}
    },
    {
        "label": "key_words",
        "kind": 5,
        "importPath": "scanner.key_words",
        "description": "scanner.key_words",
        "peekOfCode": "key_words = [\n    'func',\n    'if',\n    'else',\n    'elif',\n]",
        "detail": "scanner.key_words",
        "documentation": {}
    },
    {
        "label": "Scaner",
        "kind": 6,
        "importPath": "scanner.scaner",
        "description": "scanner.scaner",
        "peekOfCode": "class Scaner:\n    def __init__(self, dfa: DFA, key_words=None):\n        self.dfa = dfa\n        self.key_words = key_words if key_words is not None else []\n        self.tokens = []\n    def go_through_dfa(self, word):\n        if len(word) > 255:\n            raise Exception(\"Only strings could be longer than 255 characters\")\n        curr_node = self.dfa.root\n        value = \"\"",
        "detail": "scanner.scaner",
        "documentation": {}
    },
    {
        "label": "get_var_name_regex",
        "kind": 2,
        "importPath": "scanner.token_regexps",
        "description": "scanner.token_regexps",
        "peekOfCode": "def get_var_name_regex() -> BinaryNode:\n    letters = LeafNode()\n    for letter in alphabet.LETTERS:\n        letters = BinaryNode(letters, LeafNode(letter), RegexOperations.UNITE)\n    other = LeafNode()\n    for letter in alphabet.NUMBERS + alphabet.UNDERSCORE:\n        other = BinaryNode(other, LeafNode(letter), RegexOperations.UNITE)\n    other = BinaryNode(other, letters, RegexOperations.UNITE)\n    other = BinaryNode(other, None, RegexOperations.CLOSURE)\n    regex = BinaryNode(letters, other, RegexOperations.UNITE)",
        "detail": "scanner.token_regexps",
        "documentation": {}
    },
    {
        "label": "TOKENS_REGEXPS",
        "kind": 5,
        "importPath": "scanner.token_regexps",
        "description": "scanner.token_regexps",
        "peekOfCode": "TOKENS_REGEXPS = {\n    'NUM': LeafNode(),\n    'STR': LeafNode(),\n    'BOOL': LeafNode(),\n    'VARNAME': get_var_name_regex(),\n    'L_ROUND_BR': LeafNode(alphabet.L_ROUND_BR),\n    'R_ROUND_BR': LeafNode(alphabet.R_ROUND_BR),\n    'L_FIGURE_BR': LeafNode(alphabet.L_FIGURE_BR),\n    'R_FIGURE_BR': LeafNode(alphabet.R_FIGURE_BR),\n    'QUOTE': LeafNode(alphabet.QUOTE),",
        "detail": "scanner.token_regexps",
        "documentation": {}
    },
    {
        "label": "bin_dir",
        "kind": 5,
        "importPath": "venv.Scripts.activate_this",
        "description": "venv.Scripts.activate_this",
        "peekOfCode": "bin_dir = os.path.dirname(abs_file)\nbase = bin_dir[: -len(\"Scripts\") - 1]  # strip away the bin part from the __file__, plus the path separator\n# prepend bin to PATH (this file is inside the bin directory)\nos.environ[\"PATH\"] = os.pathsep.join([bin_dir] + os.environ.get(\"PATH\", \"\").split(os.pathsep))\nos.environ[\"VIRTUAL_ENV\"] = base  # virtual env is right above bin directory\n# add the virtual environments libraries to the host python import mechanism\nprev_length = len(sys.path)\nfor lib in \"..\\Lib\\site-packages\".split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path.decode(\"utf-8\") if \"\" else path)",
        "detail": "venv.Scripts.activate_this",
        "documentation": {}
    },
    {
        "label": "base",
        "kind": 5,
        "importPath": "venv.Scripts.activate_this",
        "description": "venv.Scripts.activate_this",
        "peekOfCode": "base = bin_dir[: -len(\"Scripts\") - 1]  # strip away the bin part from the __file__, plus the path separator\n# prepend bin to PATH (this file is inside the bin directory)\nos.environ[\"PATH\"] = os.pathsep.join([bin_dir] + os.environ.get(\"PATH\", \"\").split(os.pathsep))\nos.environ[\"VIRTUAL_ENV\"] = base  # virtual env is right above bin directory\n# add the virtual environments libraries to the host python import mechanism\nprev_length = len(sys.path)\nfor lib in \"..\\Lib\\site-packages\".split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path.decode(\"utf-8\") if \"\" else path)\nsys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]",
        "detail": "venv.Scripts.activate_this",
        "documentation": {}
    },
    {
        "label": "os.environ[\"PATH\"]",
        "kind": 5,
        "importPath": "venv.Scripts.activate_this",
        "description": "venv.Scripts.activate_this",
        "peekOfCode": "os.environ[\"PATH\"] = os.pathsep.join([bin_dir] + os.environ.get(\"PATH\", \"\").split(os.pathsep))\nos.environ[\"VIRTUAL_ENV\"] = base  # virtual env is right above bin directory\n# add the virtual environments libraries to the host python import mechanism\nprev_length = len(sys.path)\nfor lib in \"..\\Lib\\site-packages\".split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path.decode(\"utf-8\") if \"\" else path)\nsys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\nsys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": "venv.Scripts.activate_this",
        "documentation": {}
    },
    {
        "label": "os.environ[\"VIRTUAL_ENV\"]",
        "kind": 5,
        "importPath": "venv.Scripts.activate_this",
        "description": "venv.Scripts.activate_this",
        "peekOfCode": "os.environ[\"VIRTUAL_ENV\"] = base  # virtual env is right above bin directory\n# add the virtual environments libraries to the host python import mechanism\nprev_length = len(sys.path)\nfor lib in \"..\\Lib\\site-packages\".split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path.decode(\"utf-8\") if \"\" else path)\nsys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\nsys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": "venv.Scripts.activate_this",
        "documentation": {}
    },
    {
        "label": "prev_length",
        "kind": 5,
        "importPath": "venv.Scripts.activate_this",
        "description": "venv.Scripts.activate_this",
        "peekOfCode": "prev_length = len(sys.path)\nfor lib in \"..\\Lib\\site-packages\".split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path.decode(\"utf-8\") if \"\" else path)\nsys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\nsys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": "venv.Scripts.activate_this",
        "documentation": {}
    },
    {
        "label": "sys.path[:]",
        "kind": 5,
        "importPath": "venv.Scripts.activate_this",
        "description": "venv.Scripts.activate_this",
        "peekOfCode": "sys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\nsys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": "venv.Scripts.activate_this",
        "documentation": {}
    },
    {
        "label": "sys.real_prefix",
        "kind": 5,
        "importPath": "venv.Scripts.activate_this",
        "description": "venv.Scripts.activate_this",
        "peekOfCode": "sys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": "venv.Scripts.activate_this",
        "documentation": {}
    },
    {
        "label": "sys.prefix",
        "kind": 5,
        "importPath": "venv.Scripts.activate_this",
        "description": "venv.Scripts.activate_this",
        "peekOfCode": "sys.prefix = base",
        "detail": "venv.Scripts.activate_this",
        "documentation": {}
    },
    {
        "label": "test_minimal_dfa_from_regex",
        "kind": 2,
        "importPath": "tests",
        "description": "tests",
        "peekOfCode": "def test_minimal_dfa_from_regex():\n    a = LeafNode('a')\n    b = LeafNode('b')\n    c = LeafNode('c')\n    ab = BinaryNode(a, b, RegexOperations.CONCAT)\n    ac = BinaryNode(a, c, RegexOperations.CONCAT)\n    ab = BinaryNode(ab, None, RegexOperations.CLOSURE)\n    ac = BinaryNode(ac, None, RegexOperations.CLOSURE)\n    ab = BinaryNode(ab, ac, RegexOperations.UNITE)\n    ab = BinaryNode(ab, None, RegexOperations.CLOSURE)",
        "detail": "tests",
        "documentation": {}
    },
    {
        "label": "test_scaner",
        "kind": 2,
        "importPath": "tests",
        "description": "tests",
        "peekOfCode": "def test_scaner():\n    pass",
        "detail": "tests",
        "documentation": {}
    }
]